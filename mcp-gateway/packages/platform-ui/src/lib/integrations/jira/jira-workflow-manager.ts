/**
 * Jira Workflow Manager
 * Epic 13: Jira Integration
 *
 * Automates FORGE work item <-> Jira ticket synchronization.
 * Handles: ticket creation from work items, status sync, auto-close on completion.
 */

import { IJiraClient } from './jira-client';
import {
  JiraIssue,
  CreateIssueRequest,
  JiraStatusMapping,
  ForgeWorkItemStatus,
  ForgeJiraMapping,
  JiraDescription,
} from './jira-types';

// ============================================================================
// Interface
// ============================================================================

export interface IWorkflowManager {
  // Work Item -> Jira Sync
  createTicketFromWorkItem(workItem: ForgeWorkItem): Promise<ForgeJiraMapping>;
  syncWorkItemStatus(workItem: ForgeWorkItem): Promise<void>;
  closeTicketOnCompletion(workItem: ForgeWorkItem): Promise<void>;

  // Jira -> FORGE Sync
  getLinkedIssue(workItemId: string): Promise<JiraIssue | null>;
  syncFromJira(jiraIssueKey: string): Promise<ForgeWorkItem>;

  // Batch Operations
  syncAllPendingWorkItems(workItems: ForgeWorkItem[]): Promise<SyncResult[]>;

  // Configuration
  setStatusMappings(mappings: JiraStatusMapping[]): void;
}

export interface ForgeWorkItem {
  id: string;
  title: string;
  description?: string;
  status: ForgeWorkItemStatus;
  assignee?: string;
  component?: string;
  labels?: string[];
  jiraKey?: string;
  createdAt: string;
  updatedAt: string;
}

export interface SyncResult {
  workItemId: string;
  jiraKey?: string;
  success: boolean;
  error?: string;
  action: 'created' | 'updated' | 'transitioned' | 'skipped';
}

// ============================================================================
// Implementation
// ============================================================================

export class JiraWorkflowManager implements IWorkflowManager {
  private client: IJiraClient;
  private projectKey: string;
  private mappings: Map<string, ForgeJiraMapping> = new Map();

  private statusMappings: JiraStatusMapping[] = [
    {
      forgeStatus: 'pending',
      jiraStatusCategory: 'new',
      jiraStatusNames: ['To Do', 'Open', 'Backlog'],
    },
    {
      forgeStatus: 'in_progress',
      jiraStatusCategory: 'indeterminate',
      jiraStatusNames: ['In Progress', 'In Review', 'Development'],
    },
    {
      forgeStatus: 'review',
      jiraStatusCategory: 'indeterminate',
      jiraStatusNames: ['In Review', 'Code Review', 'QA'],
    },
    {
      forgeStatus: 'completed',
      jiraStatusCategory: 'done',
      jiraStatusNames: ['Done', 'Closed', 'Resolved'],
    },
    {
      forgeStatus: 'failed',
      jiraStatusCategory: 'done',
      jiraStatusNames: ["Won't Do", 'Cancelled', 'Failed'],
    },
  ];

  constructor(client: IJiraClient, projectKey: string) {
    this.client = client;
    this.projectKey = projectKey;
  }

  // --------------------------------------------------------------------------
  // Work Item -> Jira Sync
  // --------------------------------------------------------------------------

  async createTicketFromWorkItem(
    workItem: ForgeWorkItem
  ): Promise<ForgeJiraMapping> {
    // Check if already linked
    const existingMapping = this.mappings.get(workItem.id);
    if (existingMapping) {
      return existingMapping;
    }

    // Build Jira issue request
    const request: CreateIssueRequest = {
      fields: {
        project: { key: this.projectKey },
        summary: workItem.title,
        description: this.buildDescription(workItem),
        issuetype: { name: 'Task' },
        labels: ['forge-generated', ...(workItem.labels || [])],
        ...(workItem.component
          ? { components: [{ name: workItem.component }] }
          : {}),
      },
    };

    // Create in Jira
    const response = await this.client.createIssue(request);

    // Store mapping
    const mapping: ForgeJiraMapping = {
      workItemId: workItem.id,
      jiraIssueKey: response.key,
      jiraIssueId: response.id,
      linkedAt: new Date().toISOString(),
    };

    this.mappings.set(workItem.id, mapping);

    // Add comment with FORGE reference
    await this.client.addComment(
      response.key,
      `Linked to FORGE work item: ${workItem.id}\nGenerated by FORGE Platform automation.`
    );

    return mapping;
  }

  async syncWorkItemStatus(workItem: ForgeWorkItem): Promise<void> {
    const mapping = this.mappings.get(workItem.id);
    if (!mapping) {
      throw new Error(`No Jira mapping found for work item ${workItem.id}`);
    }

    // Get current Jira issue
    const jiraIssue = await this.client.getIssue(mapping.jiraIssueKey);

    // Determine target status
    const targetMapping = this.statusMappings.find(
      (m) => m.forgeStatus === workItem.status
    );
    if (!targetMapping) {
      return; // No mapping for this status
    }

    // Check if transition needed
    const currentCategory = jiraIssue.fields.status.statusCategory.key;
    if (currentCategory === targetMapping.jiraStatusCategory) {
      return; // Already in correct category
    }

    // Get available transitions
    const transitions = await this.client.getTransitions(mapping.jiraIssueKey);

    // Find transition to target status
    const transition = transitions.transitions.find(
      (t) =>
        targetMapping.jiraStatusNames.includes(t.to.name) ||
        t.to.statusCategory.key === targetMapping.jiraStatusCategory
    );

    if (transition) {
      await this.client.transitionIssue(mapping.jiraIssueKey, transition.id);

      // Update sync timestamp
      mapping.syncedAt = new Date().toISOString();
    }
  }

  async closeTicketOnCompletion(workItem: ForgeWorkItem): Promise<void> {
    if (workItem.status !== 'completed' && workItem.status !== 'failed') {
      return;
    }

    await this.syncWorkItemStatus(workItem);

    // Add completion comment
    const mapping = this.mappings.get(workItem.id);
    if (mapping) {
      const status =
        workItem.status === 'completed' ? 'Completed' : 'Failed';
      await this.client.addComment(
        mapping.jiraIssueKey,
        `${status} via FORGE automation at ${new Date().toISOString()}`
      );
    }
  }

  // --------------------------------------------------------------------------
  // Jira -> FORGE Sync
  // --------------------------------------------------------------------------

  async getLinkedIssue(workItemId: string): Promise<JiraIssue | null> {
    const mapping = this.mappings.get(workItemId);
    if (!mapping) {
      return null;
    }

    try {
      return await this.client.getIssue(mapping.jiraIssueKey);
    } catch {
      return null;
    }
  }

  async syncFromJira(jiraIssueKey: string): Promise<ForgeWorkItem> {
    const jiraIssue = await this.client.getIssue(jiraIssueKey);

    // Map Jira status to FORGE status
    const statusCategory = jiraIssue.fields.status.statusCategory.key;
    const forgeStatus = this.mapJiraToForgeStatus(statusCategory);

    return {
      id: `jira-${jiraIssue.id}`,
      title: jiraIssue.fields.summary,
      description: this.extractDescription(jiraIssue.fields.description),
      status: forgeStatus,
      labels: jiraIssue.fields.labels,
      jiraKey: jiraIssue.key,
      createdAt: jiraIssue.fields.created,
      updatedAt: jiraIssue.fields.updated,
    };
  }

  // --------------------------------------------------------------------------
  // Batch Operations
  // --------------------------------------------------------------------------

  async syncAllPendingWorkItems(
    workItems: ForgeWorkItem[]
  ): Promise<SyncResult[]> {
    const results: SyncResult[] = [];

    for (const workItem of workItems) {
      try {
        const mapping = this.mappings.get(workItem.id);

        if (!mapping) {
          // Create new ticket
          const newMapping = await this.createTicketFromWorkItem(workItem);
          results.push({
            workItemId: workItem.id,
            jiraKey: newMapping.jiraIssueKey,
            success: true,
            action: 'created',
          });
        } else {
          // Sync status
          await this.syncWorkItemStatus(workItem);
          results.push({
            workItemId: workItem.id,
            jiraKey: mapping.jiraIssueKey,
            success: true,
            action: 'updated',
          });
        }
      } catch (error) {
        results.push({
          workItemId: workItem.id,
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error',
          action: 'skipped',
        });
      }
    }

    return results;
  }

  // --------------------------------------------------------------------------
  // Configuration
  // --------------------------------------------------------------------------

  setStatusMappings(mappings: JiraStatusMapping[]): void {
    this.statusMappings = mappings;
  }

  getMapping(workItemId: string): ForgeJiraMapping | undefined {
    return this.mappings.get(workItemId);
  }

  // --------------------------------------------------------------------------
  // Private Helpers
  // --------------------------------------------------------------------------

  private buildDescription(workItem: ForgeWorkItem): JiraDescription {
    const lines = [
      workItem.description || 'No description provided.',
      '',
      '---',
      `*FORGE Work Item ID:* ${workItem.id}`,
      `*Created:* ${workItem.createdAt}`,
    ];

    return {
      type: 'doc',
      version: 1,
      content: lines.map((line) => ({
        type: 'paragraph' as const,
        content: line ? [{ type: 'text' as const, text: line }] : [],
      })),
    };
  }

  private extractDescription(description?: JiraDescription): string {
    if (!description || !description.content) {
      return '';
    }

    return description.content
      .filter((block) => block.type === 'paragraph')
      .map((block) => block.content?.map((c) => c.text).join('') || '')
      .join('\n');
  }

  private mapJiraToForgeStatus(
    category: 'new' | 'indeterminate' | 'done'
  ): ForgeWorkItemStatus {
    switch (category) {
      case 'new':
        return 'pending';
      case 'indeterminate':
        return 'in_progress';
      case 'done':
        return 'completed';
      default:
        return 'pending';
    }
  }
}
