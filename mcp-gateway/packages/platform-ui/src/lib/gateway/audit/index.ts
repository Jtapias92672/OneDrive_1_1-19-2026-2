/**
 * MCP Security Gateway - Audit Module
 *
 * @epic 3.7 - Compliance & Validation
 * @task 3.7.7-3.7.10 - Audit Logging
 * @owner joe@arcfoundry.ai
 * @created 2026-01-22
 *
 * @description
 *   Comprehensive audit logging module for DCMA/DFARS compliance.
 *   Provides immutable logging, evidence binding, and retention management.
 *
 * @compliance
 *   - DCMA 252.204-7012: Audit and retention requirements
 *   - NIST SP 800-53: AU family controls
 *   - SOC 2: Logging and monitoring
 */

// ============================================
// AUDIT LOGGER
// ============================================

export {
  ImmutableAuditLogger,
  type AuditEventType,
  type AuditActor,
  type AuditLogEntry,
  type AuditTarget,
  type AuditLoggerConfig,
  type AuditHandler,
} from './audit-logger';

// ============================================
// DCMA FORMATTER
// ============================================

export {
  DCMAFormatter,
  type DCMAAuditEntry,
  type CUICategory,
  type EvidencePack,
  type DCMAComplianceLevel,
  type DCMAFormatterConfig,
} from './dcma-format';

// ============================================
// EVIDENCE BINDING
// ============================================

export {
  EvidenceBinder,
  type EvidenceBinding,
  type EvidenceType,
  type EvidenceArtifact,
  type CustodyRecord,
  type ValidationResult,
  type EvidenceBinderConfig,
} from './evidence-binding';

// ============================================
// RETENTION MANAGEMENT
// ============================================

export {
  RetentionManager,
  type RetentionTier,
  type StorageLocation,
  type ArchivedBatch,
  type RetentionPolicy,
  type RetentionStatus,
  type RetentionManagerConfig,
} from './retention';

// ============================================
// UNIFIED AUDIT SYSTEM
// ============================================

import { ImmutableAuditLogger, AuditLogEntry, AuditActor, AuditEventType, AuditLoggerConfig } from './audit-logger';
import { DCMAFormatter, DCMAFormatterConfig } from './dcma-format';
import { EvidenceBinder, EvidenceBinderConfig, EvidenceType } from './evidence-binding';
import { RetentionManager, RetentionManagerConfig } from './retention';

/**
 * Unified audit system configuration
 */
export interface AuditSystemConfig {
  /** Logger configuration */
  logger?: Partial<AuditLoggerConfig>;

  /** Formatter configuration */
  formatter?: Partial<DCMAFormatterConfig>;

  /** Evidence binder configuration */
  evidenceBinder?: Partial<EvidenceBinderConfig>;

  /** Retention manager configuration */
  retention?: Partial<RetentionManagerConfig>;

  /** Auto-archive threshold (number of entries) */
  autoArchiveThreshold?: number;

  /** Auto-bind evidence for security events */
  autoBindSecurityEvents?: boolean;
}

/**
 * Unified Audit System
 *
 * Combines all audit components into a single, cohesive system
 * for DCMA/DFARS compliant audit logging.
 */
export class AuditSystem {
  private logger: ImmutableAuditLogger;
  private formatter: DCMAFormatter;
  private evidenceBinder: EvidenceBinder;
  private retentionManager: RetentionManager;
  private config: AuditSystemConfig;
  private pendingEntries: AuditLogEntry[] = [];

  constructor(config: AuditSystemConfig = {}) {
    this.config = {
      autoArchiveThreshold: 1000,
      autoBindSecurityEvents: true,
      ...config,
    };

    this.logger = new ImmutableAuditLogger(this.config.logger);
    this.formatter = new DCMAFormatter(this.config.formatter);
    this.evidenceBinder = new EvidenceBinder(this.config.evidenceBinder);
    this.retentionManager = new RetentionManager(this.config.retention);
  }

  /**
   * Log an audit event
   */
  async log(
    eventType: AuditEventType,
    actor: AuditActor,
    outcome: AuditLogEntry['outcome'],
    details: Record<string, unknown>,
    options?: {
      target?: AuditLogEntry['target'];
      riskLevel?: AuditLogEntry['riskLevel'];
      cuiCategory?: string;
    }
  ): Promise<AuditLogEntry> {
    const entry = await this.logger.log(eventType, actor, outcome, details, options);

    // Track for archival
    this.pendingEntries.push(entry);

    // Auto-archive if threshold reached
    if (this.pendingEntries.length >= (this.config.autoArchiveThreshold || 1000)) {
      await this.archivePendingEntries();
    }

    // Auto-bind security events
    if (this.config.autoBindSecurityEvents && this.isSecurityEvent(eventType)) {
      this.evidenceBinder.createBinding('SECURITY_INCIDENT', [entry], {
        metadata: { autoGenerated: true },
      });
    }

    return entry;
  }

  /**
   * Log tool invocation
   */
  async logToolInvocation(
    actor: AuditActor,
    toolName: string,
    params: Record<string, unknown>,
    options?: {
      tenantId?: string;
      riskLevel?: AuditLogEntry['riskLevel'];
    }
  ): Promise<AuditLogEntry> {
    const entry = await this.logger.logToolInvocation(actor, toolName, params, options);
    this.pendingEntries.push(entry);
    return entry;
  }

  /**
   * Log security alert
   */
  async logSecurityAlert(
    alertType: string,
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL',
    details: Record<string, unknown>,
    options?: {
      actor?: AuditActor;
      tenantId?: string;
    }
  ): Promise<AuditLogEntry> {
    const entry = await this.logger.logSecurityAlert(alertType, severity, details, options);
    this.pendingEntries.push(entry);

    // Always bind security alerts as evidence
    if (this.config.autoBindSecurityEvents) {
      this.evidenceBinder.createBinding('SECURITY_INCIDENT', [entry], {
        metadata: {
          alertType,
          severity,
          autoGenerated: true,
        },
      });
    }

    return entry;
  }

  /**
   * Create evidence binding for entries
   */
  createEvidenceBinding(
    type: EvidenceType,
    entries: AuditLogEntry[],
    options?: Parameters<EvidenceBinder['createBinding']>[2]
  ) {
    return this.evidenceBinder.createBinding(type, entries, options);
  }

  /**
   * Generate DCMA-compliant evidence pack
   */
  generateEvidencePack(
    entries: AuditLogEntry[],
    options?: Parameters<DCMAFormatter['generateEvidencePack']>[1]
  ) {
    return this.formatter.generateEvidencePack(entries, options);
  }

  /**
   * Archive pending entries
   */
  async archivePendingEntries(): Promise<void> {
    if (this.pendingEntries.length === 0) return;

    const entries = [...this.pendingEntries];
    this.pendingEntries = [];

    await this.retentionManager.archiveEntries(entries);
  }

  /**
   * Verify audit chain integrity
   */
  verifyChainIntegrity(): ReturnType<ImmutableAuditLogger['verifyChain']> {
    return this.logger.verifyChain();
  }

  /**
   * Verify retention compliance
   */
  verifyRetentionCompliance(): ReturnType<RetentionManager['verifyCompliance']> {
    return this.retentionManager.verifyCompliance();
  }

  /**
   * Run maintenance tasks (transitions, purges)
   */
  async runMaintenance(): Promise<{
    transitioned: number;
    purged: number;
    errors: string[];
  }> {
    const transitionResult = await this.retentionManager.transitionEntries();
    const purgeResult = await this.retentionManager.purgeExpiredEntries();

    return {
      transitioned: transitionResult.transitioned,
      purged: purgeResult.purged,
      errors: [...transitionResult.errors, ...purgeResult.errors],
    };
  }

  /**
   * Get audit statistics
   */
  getStatistics(): {
    logger: ReturnType<ImmutableAuditLogger['getStats']>;
    retention: ReturnType<RetentionManager['getStatistics']>;
    evidenceBindings: number;
  } {
    return {
      logger: this.logger.getStats(),
      retention: this.retentionManager.getStatistics(),
      evidenceBindings: this.evidenceBinder.getAllBindings().length,
    };
  }

  /**
   * Get underlying components for advanced usage
   */
  getComponents(): {
    logger: ImmutableAuditLogger;
    formatter: DCMAFormatter;
    evidenceBinder: EvidenceBinder;
    retentionManager: RetentionManager;
  } {
    return {
      logger: this.logger,
      formatter: this.formatter,
      evidenceBinder: this.evidenceBinder,
      retentionManager: this.retentionManager,
    };
  }

  /**
   * Check if event type is security-related
   */
  private isSecurityEvent(eventType: AuditEventType): boolean {
    const securityEvents: AuditEventType[] = [
      'SECURITY_ALERT',
      'AUTHORIZATION',
      'ERROR',
    ];
    return securityEvents.includes(eventType);
  }

  /**
   * Shutdown and archive remaining entries
   */
  async shutdown(): Promise<void> {
    await this.archivePendingEntries();
  }
}

// ============================================
// DEFAULT EXPORT
// ============================================

export { AuditSystem as default };
