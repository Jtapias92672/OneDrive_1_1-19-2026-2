# Epic 3.5: MCP Gateway Foundation - Task Breakdown

**Total Tasks:** 15  
**Estimated Tokens:** 50K total (~3.3K per task)  
**Estimated Time:** 5 days

---

## Phase 1: Gateway Core Infrastructure (US-3.5.1)

### Task 3.5.1.1: Create mcp-gateway package structure

**Time:** 5 minutes  
**Tokens:** ~3K  

**Files to CREATE:**
- `packages/mcp-gateway/package.json`
- `packages/mcp-gateway/tsconfig.json`
- `packages/mcp-gateway/src/index.ts`
- `packages/mcp-gateway/src/core/types.ts`
- `packages/mcp-gateway/README.md`

**Acceptance Criteria:**
- [ ] Package builds successfully
- [ ] TypeScript strict mode enabled
- [ ] Exports main gateway types
- [ ] pnpm workspace recognizes package

**Commands:**
```bash
mkdir -p packages/mcp-gateway/src/core
cd packages/mcp-gateway
pnpm init
pnpm add zod @anthropic-ai/sdk
pnpm add -D @types/node typescript vitest
```

**Verification:**
```bash
pnpm --filter @forge/mcp-gateway build
```

---

### Task 3.5.1.2: Implement gateway core types

**Time:** 10 minutes  
**Tokens:** ~4K  

**Files to CREATE:**
- `packages/mcp-gateway/src/core/types.ts`
- `packages/mcp-gateway/src/core/errors.ts`

**Acceptance Criteria:**
- [ ] ToolCallRequest interface defined
- [ ] ToolCallResponse interface defined
- [ ] RiskLevel enum defined
- [ ] Gateway error classes defined
- [ ] Zod schemas for runtime validation

**Implementation:**
```typescript
// packages/mcp-gateway/src/core/types.ts
import { z } from 'zod';

export enum RiskLevel {
  LOW = 0,
  MEDIUM = 1,
  HIGH = 2,
  CRITICAL = 3,
}

export const ToolCallRequestSchema = z.object({
  tool: z.object({
    name: z.string(),
    description: z.string(),
    inputSchema: z.record(z.unknown()),
  }),
  params: z.record(z.unknown()),
  context: z.object({
    userId: z.string(),
    projectId: z.string(),
    environment: z.enum(['development', 'staging', 'production']),
  }),
});

export type ToolCallRequest = z.infer<typeof ToolCallRequestSchema>;

export interface ToolCallResponse {
  success: boolean;
  result?: unknown;
  error?: string;
  metadata: {
    riskLevel: RiskLevel;
    approvalRequired: boolean;
    executionTime: number;
  };
}
```

**Verification:**
```bash
pnpm --filter @forge/mcp-gateway test:types
```

---

### Task 3.5.1.3: Implement MCPGateway orchestrator

**Time:** 15 minutes  
**Tokens:** ~5K  

**Files to CREATE:**
- `packages/mcp-gateway/src/core/gateway.ts`
- `packages/mcp-gateway/src/core/config.ts`
- `packages/mcp-gateway/tests/unit/gateway.test.ts`

**Acceptance Criteria:**
- [ ] MCPGateway class implements handleToolCall method
- [ ] Request validation using Zod schemas
- [ ] Integration points for CARS, approval, integrity modules
- [ ] Error handling for invalid requests
- [ ] Unit tests cover happy path and error cases

**Implementation:**
```typescript
// packages/mcp-gateway/src/core/gateway.ts
import { ToolCallRequest, ToolCallResponse, RiskLevel } from './types.js';
import { CARSEngine } from '../cars/risk-assessment.js';
import { ApprovalEngine } from '../approval/approval-engine.js';
import { ToolIntegrityMonitor } from '../monitoring/tool-integrity.js';

export class MCPGateway {
  constructor(
    private carsEngine: CARSEngine,
    private approvalEngine: ApprovalEngine,
    private integrityMonitor: ToolIntegrityMonitor
  ) {}

  async handleToolCall(request: ToolCallRequest): Promise<ToolCallResponse> {
    const startTime = Date.now();
    
    try {
      // Step 1: Validate request structure
      this.validateRequest(request);
      
      // Step 2: Verify tool integrity
      await this.integrityMonitor.verifyIntegrity(request.tool);
      
      // Step 3: CARS risk assessment
      const riskAssessment = await this.carsEngine.assess(request);
      
      // Step 4: Route based on risk
      let result;
      if (riskAssessment.requiresApproval) {
        result = await this.approvalEngine.requestApproval(
          request,
          riskAssessment
        );
      } else {
        result = await this.executeToolCall(request);
      }
      
      return {
        success: true,
        result,
        metadata: {
          riskLevel: riskAssessment.riskLevel,
          approvalRequired: riskAssessment.requiresApproval,
          executionTime: Date.now() - startTime,
        },
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        metadata: {
          riskLevel: RiskLevel.CRITICAL,
          approvalRequired: false,
          executionTime: Date.now() - startTime,
        },
      };
    }
  }
  
  private validateRequest(request: ToolCallRequest): void {
    // Zod validation in next task
  }
  
  private async executeToolCall(request: ToolCallRequest): Promise<unknown> {
    // Placeholder - actual execution in Epic 3
    return { status: 'executed' };
  }
}
```

**Verification:**
```bash
pnpm --filter @forge/mcp-gateway test:unit -- gateway.test
```

---

### Task 3.5.1.4: Implement request validation

**Time:** 5 minutes  
**Tokens:** ~3K  

**Files to MODIFY:**
- `packages/mcp-gateway/src/core/gateway.ts`

**Files to CREATE:**
- `packages/mcp-gateway/tests/unit/validation.test.ts`

**Acceptance Criteria:**
- [ ] Zod schema validation integrated
- [ ] Validation errors thrown with clear messages
- [ ] Tests cover invalid requests
- [ ] Performance: validation <1ms per request

**Implementation:**
```typescript
// Add to gateway.ts
import { ToolCallRequestSchema } from './types.js';

private validateRequest(request: ToolCallRequest): void {
  const result = ToolCallRequestSchema.safeParse(request);
  
  if (!result.success) {
    throw new ValidationError(
      `Invalid tool call request: ${result.error.message}`
    );
  }
}
```

**Verification:**
```bash
pnpm --filter @forge/mcp-gateway test:validation
```

---

## Phase 2: CARS Risk Assessment (US-3.5.2)

### Task 3.5.2.1: Define CARS risk levels and matrix

**Time:** 10 minutes  
**Tokens:** ~4K  

**Files to CREATE:**
- `packages/mcp-gateway/src/cars/risk-levels.ts`
- `packages/mcp-gateway/src/cars/risk-matrix.ts`
- `packages/mcp-gateway/tests/unit/risk-matrix.test.ts`

**Acceptance Criteria:**
- [ ] RiskLevel enum matches CARS framework
- [ ] Tool risk matrix covers all FORGE tools
- [ ] Risk matrix is extensible (easy to add new tools)
- [ ] Tests verify risk mappings

**Implementation:**
```typescript
// packages/mcp-gateway/src/cars/risk-matrix.ts
import { RiskLevel } from '../core/types.js';

export const TOOL_RISK_MATRIX: Record<string, RiskLevel> = {
  // File operations
  'filesystem_write': RiskLevel.HIGH,
  'filesystem_delete': RiskLevel.CRITICAL,
  'filesystem_read': RiskLevel.MEDIUM,
  'filesystem_list': RiskLevel.LOW,
  
  // FORGE operations
  'forge_converge': RiskLevel.MEDIUM,
  'answer_contract_validate': RiskLevel.LOW,
  'evidence_pack_create': RiskLevel.LOW,
  
  // Future: External integrations (Epic 3.6)
  'jira_create_epic': RiskLevel.MEDIUM,
  'github_push': RiskLevel.CRITICAL,
  'slack_post_message': RiskLevel.LOW,
};

export function getToolRisk(toolName: string): RiskLevel {
  return TOOL_RISK_MATRIX[toolName] ?? RiskLevel.CRITICAL; // Unknown = CRITICAL
}
```

**Verification:**
```bash
pnpm --filter @forge/mcp-gateway test:risk-matrix
```

---

### Task 3.5.2.2: Implement CARS context types

**Time:** 5 minutes  
**Tokens:** ~3K  

**Files to CREATE:**
- `packages/mcp-gateway/src/cars/context.ts`

**Acceptance Criteria:**
- [ ] CARSContext interface defined
- [ ] Context includes userId, projectId, environment, userRole
- [ ] Context validation

**Implementation:**
```typescript
// packages/mcp-gateway/src/cars/context.ts
import { z } from 'zod';

export const CARSContextSchema = z.object({
  userId: z.string().uuid(),
  projectId: z.string().uuid(),
  environment: z.enum(['development', 'staging', 'production']),
  userRole: z.enum(['viewer', 'developer', 'admin']),
});

export type CARSContext = z.infer<typeof CARSContextSchema>;
```

**Verification:**
```bash
pnpm --filter @forge/mcp-gateway test:cars-context
```

---

### Task 3.5.2.3: Implement CARS risk assessment engine

**Time:** 15 minutes  
**Tokens:** ~5K  

**Files to CREATE:**
- `packages/mcp-gateway/src/cars/risk-assessment.ts`
- `packages/mcp-gateway/tests/unit/risk-assessment.test.ts`

**Acceptance Criteria:**
- [ ] CARSEngine class implements assess method
- [ ] Base risk from tool matrix
- [ ] Context-aware risk escalation (production +1 level)
- [ ] Risk reasoning generated
- [ ] Tests cover all risk levels and escalation scenarios

**Implementation:**
```typescript
// packages/mcp-gateway/src/cars/risk-assessment.ts
import { RiskLevel, ToolCallRequest } from '../core/types.js';
import { getToolRisk } from './risk-matrix.js';
import { CARSContext } from './context.js';

export interface RiskAssessment {
  riskLevel: RiskLevel;
  reasoning: string;
  requiresApproval: boolean;
  contextFactors: string[];
}

export class CARSEngine {
  async assess(
    request: ToolCallRequest,
    context?: CARSContext
  ): Promise<RiskAssessment> {
    let riskLevel = getToolRisk(request.tool.name);
    const contextFactors: string[] = [];
    
    // Context-aware escalation
    if (context) {
      if (context.environment === 'production') {
        riskLevel = this.escalateRisk(riskLevel);
        contextFactors.push('Production environment (+1 risk level)');
      }
      
      if (context.userRole === 'viewer' && riskLevel >= RiskLevel.MEDIUM) {
        riskLevel = RiskLevel.CRITICAL;
        contextFactors.push('Viewer role attempting MEDIUM+ operation');
      }
    }
    
    return {
      riskLevel,
      reasoning: this.explainRisk(request.tool.name, riskLevel, contextFactors),
      requiresApproval: riskLevel >= RiskLevel.MEDIUM,
      contextFactors,
    };
  }
  
  private escalateRisk(current: RiskLevel): RiskLevel {
    return Math.min(current + 1, RiskLevel.CRITICAL) as RiskLevel;
  }
  
  private explainRisk(
    toolName: string,
    riskLevel: RiskLevel,
    factors: string[]
  ): string {
    const base = `Tool ${toolName} assessed at ${RiskLevel[riskLevel]} risk.`;
    return factors.length > 0
      ? `${base} Factors: ${factors.join(', ')}`
      : base;
  }
}
```

**Verification:**
```bash
pnpm --filter @forge/mcp-gateway test:cars
```

---

### Task 3.5.2.4: Integrate CARS with gateway

**Time:** 5 minutes  
**Tokens:** ~2K  

**Files to MODIFY:**
- `packages/mcp-gateway/src/core/gateway.ts`

**Acceptance Criteria:**
- [ ] Gateway calls CARS engine for every request
- [ ] CARSContext extracted from ToolCallRequest
- [ ] Risk assessment logged
- [ ] Integration tests pass

**Verification:**
```bash
pnpm --filter @forge/mcp-gateway test:integration -- cars-gateway
```

---

## Phase 3: Human Approval Engine (US-3.5.3)

### Task 3.5.3.1: Create approval database schema

**Time:** 10 minutes  
**Tokens:** ~4K  

**Files to CREATE:**
- `packages/mcp-gateway/src/approval/schema.ts`
- `packages/mcp-gateway/src/approval/db.ts`

**Acceptance Criteria:**
- [ ] ApprovalRequest interface defined
- [ ] Database schema includes: id, tool, params, riskLevel, status, expiresAt
- [ ] Status enum: PENDING, APPROVED, DENIED, EXPIRED
- [ ] In-memory implementation for testing (production DB in Epic 3.6)

**Implementation:**
```typescript
// packages/mcp-gateway/src/approval/schema.ts
export enum ApprovalStatus {
  PENDING = 'PENDING',
  APPROVED = 'APPROVED',
  DENIED = 'DENIED',
  EXPIRED = 'EXPIRED',
}

export interface ApprovalRequest {
  id: string;
  toolName: string;
  params: Record<string, unknown>;
  riskLevel: RiskLevel;
  reasoning: string;
  status: ApprovalStatus;
  createdAt: Date;
  expiresAt: Date;
  decidedBy?: string;
  decidedAt?: Date;
}
```

**Verification:**
```bash
pnpm --filter @forge/mcp-gateway test:approval-schema
```

---

### Task 3.5.3.2: Implement approval engine core

**Time:** 15 minutes  
**Tokens:** ~5K  

**Files to CREATE:**
- `packages/mcp-gateway/src/approval/approval-engine.ts`
- `packages/mcp-gateway/tests/unit/approval-engine.test.ts`

**Acceptance Criteria:**
- [ ] ApprovalEngine.requestApproval() creates approval request
- [ ] 5-minute expiry enforced
- [ ] Waits for human decision (async)
- [ ] Returns result or throws ApprovalDeniedError
- [ ] Tests cover approval, denial, timeout scenarios

**Implementation:**
```typescript
// packages/mcp-gateway/src/approval/approval-engine.ts
import { v4 as uuidv4 } from 'uuid';
import { RiskAssessment } from '../cars/risk-assessment.js';
import { ApprovalRequest, ApprovalStatus } from './schema.js';

export class ApprovalEngine {
  private approvalRequests = new Map<string, ApprovalRequest>();
  private readonly APPROVAL_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes
  
  async requestApproval(
    request: ToolCallRequest,
    riskAssessment: RiskAssessment
  ): Promise<unknown> {
    const approvalId = uuidv4();
    const expiresAt = new Date(Date.now() + this.APPROVAL_TIMEOUT_MS);
    
    const approvalRequest: ApprovalRequest = {
      id: approvalId,
      toolName: request.tool.name,
      params: request.params,
      riskLevel: riskAssessment.riskLevel,
      reasoning: riskAssessment.reasoning,
      status: ApprovalStatus.PENDING,
      createdAt: new Date(),
      expiresAt,
    };
    
    this.approvalRequests.set(approvalId, approvalRequest);
    
    // Emit event for UI (WebSocket in Epic 3.6)
    await this.emitApprovalNeeded(approvalId);
    
    // Wait for decision
    const decision = await this.waitForDecision(approvalId, expiresAt);
    
    if (decision.status === ApprovalStatus.APPROVED) {
      // Execute tool (gateway handles this)
      return { approved: true, approvalId };
    } else {
      throw new ApprovalDeniedError(
        `Approval denied for ${request.tool.name}: ${decision.status}`
      );
    }
  }
  
  private async waitForDecision(
    approvalId: string,
    expiresAt: Date
  ): Promise<ApprovalRequest> {
    const pollInterval = 1000; // Check every second
    
    while (Date.now() < expiresAt.getTime()) {
      const approval = this.approvalRequests.get(approvalId);
      
      if (approval && approval.status !== ApprovalStatus.PENDING) {
        return approval;
      }
      
      await new Promise(resolve => setTimeout(resolve, pollInterval));
    }
    
    // Timeout - mark as EXPIRED
    const approval = this.approvalRequests.get(approvalId)!;
    approval.status = ApprovalStatus.EXPIRED;
    this.approvalRequests.set(approvalId, approval);
    
    return approval;
  }
  
  private async emitApprovalNeeded(approvalId: string): Promise<void> {
    // Placeholder - WebSocket in Epic 3.6
    console.log(`[Approval Needed] ID: ${approvalId}`);
  }
}
```

**Verification:**
```bash
pnpm --filter @forge/mcp-gateway test:approval-engine
```

---

### Task 3.5.3.3: Implement approval API endpoints

**Time:** 10 minutes  
**Tokens:** ~4K  

**Files to CREATE:**
- `packages/mcp-gateway/src/approval/api.ts`
- `packages/mcp-gateway/tests/integration/approval-api.test.ts`

**Acceptance Criteria:**
- [ ] GET /api/mcp/approvals - list pending approvals
- [ ] POST /api/mcp/approvals/:id/approve - approve request
- [ ] POST /api/mcp/approvals/:id/deny - deny request
- [ ] API validates approvalId exists
- [ ] API prevents approval of expired requests

**Implementation:**
```typescript
// packages/mcp-gateway/src/approval/api.ts
import { Router } from 'express';
import { ApprovalEngine } from './approval-engine.js';
import { ApprovalStatus } from './schema.js';

export function createApprovalRouter(engine: ApprovalEngine): Router {
  const router = Router();
  
  router.get('/approvals', async (req, res) => {
    const pending = Array.from(engine['approvalRequests'].values())
      .filter(a => a.status === ApprovalStatus.PENDING);
    res.json({ approvals: pending });
  });
  
  router.post('/approvals/:id/approve', async (req, res) => {
    const { id } = req.params;
    const { userId } = req.body;
    
    const approval = engine['approvalRequests'].get(id);
    if (!approval) {
      return res.status(404).json({ error: 'Approval request not found' });
    }
    
    if (Date.now() > approval.expiresAt.getTime()) {
      return res.status(400).json({ error: 'Approval request expired' });
    }
    
    approval.status = ApprovalStatus.APPROVED;
    approval.decidedBy = userId;
    approval.decidedAt = new Date();
    
    res.json({ success: true, approval });
  });
  
  router.post('/approvals/:id/deny', async (req, res) => {
    // Similar to approve
  });
  
  return router;
}
```

**Verification:**
```bash
pnpm --filter @forge/mcp-gateway test:approval-api
curl http://localhost:3000/api/mcp/approvals
```

---

### Task 3.5.3.4: Integrate approval engine with gateway

**Time:** 5 minutes  
**Tokens:** ~2K  

**Files to MODIFY:**
- `packages/mcp-gateway/src/core/gateway.ts`

**Acceptance Criteria:**
- [ ] Gateway calls approval engine for MEDIUM+ risk
- [ ] Approval timeout handled gracefully
- [ ] Integration tests cover approval flow

**Verification:**
```bash
pnpm --filter @forge/mcp-gateway test:integration -- gateway-approval
```

---

## Phase 4: Tool Integrity Monitoring (US-3.5.4)

### Task 3.5.4.1: Implement tool fingerprinting

**Time:** 10 minutes  
**Tokens:** ~4K  

**Files to CREATE:**
- `packages/mcp-gateway/src/monitoring/fingerprinting.ts`
- `packages/mcp-gateway/tests/unit/fingerprinting.test.ts`

**Acceptance Criteria:**
- [ ] SHA-256 hash of tool definition (name + description + schema)
- [ ] Canonical JSON serialization (consistent ordering)
- [ ] Fingerprint includes timestamp
- [ ] Tests verify hash stability

**Implementation:**
```typescript
// packages/mcp-gateway/src/monitoring/fingerprinting.ts
import { createHash } from 'crypto';
import { MCPTool } from '../core/types.js';

export interface ToolFingerprint {
  hash: string;
  timestamp: Date;
}

export function calculateFingerprint(tool: MCPTool): ToolFingerprint {
  // Canonical representation (deterministic)
  const canonical = JSON.stringify({
    name: tool.name,
    description: tool.description,
    inputSchema: sortKeys(tool.inputSchema),
  });
  
  const hash = createHash('sha256')
    .update(canonical, 'utf8')
    .digest('hex');
  
  return {
    hash,
    timestamp: new Date(),
  };
}

function sortKeys(obj: any): any {
  if (typeof obj !== 'object' || obj === null) return obj;
  if (Array.isArray(obj)) return obj.map(sortKeys);
  
  return Object.keys(obj)
    .sort()
    .reduce((result, key) => {
      result[key] = sortKeys(obj[key]);
      return result;
    }, {} as any);
}
```

**Verification:**
```bash
pnpm --filter @forge/mcp-gateway test:fingerprinting
```

---

### Task 3.5.4.2: Implement tool registry

**Time:** 10 minutes  
**Tokens:** ~4K  

**Files to CREATE:**
- `packages/mcp-gateway/src/monitoring/tool-registry.ts`
- `packages/mcp-gateway/tests/unit/tool-registry.test.ts`

**Acceptance Criteria:**
- [ ] ToolRegistry stores fingerprints (in-memory for Epic 3.5)
- [ ] registerTool() adds tool fingerprint
- [ ] getFingerprint() retrieves stored fingerprint
- [ ] Tests cover registration and retrieval

**Implementation:**
```typescript
// packages/mcp-gateway/src/monitoring/tool-registry.ts
import { ToolFingerprint, calculateFingerprint } from './fingerprinting.js';
import { MCPTool } from '../core/types.js';

export class ToolRegistry {
  private registry = new Map<string, ToolFingerprint>();
  
  async registerTool(tool: MCPTool): Promise<void> {
    const fingerprint = calculateFingerprint(tool);
    this.registry.set(tool.name, fingerprint);
  }
  
  async getFingerprint(toolName: string): Promise<ToolFingerprint | null> {
    return this.registry.get(toolName) || null;
  }
  
  async isRegistered(toolName: string): Promise<boolean> {
    return this.registry.has(toolName);
  }
}
```

**Verification:**
```bash
pnpm --filter @forge/mcp-gateway test:tool-registry
```

---

### Task 3.5.4.3: Implement integrity monitor with alerting

**Time:** 15 minutes  
**Tokens:** ~5K  

**Files to CREATE:**
- `packages/mcp-gateway/src/monitoring/tool-integrity.ts`
- `packages/mcp-gateway/tests/unit/tool-integrity.test.ts`

**Acceptance Criteria:**
- [ ] ToolIntegrityMonitor verifies tool integrity before execution
- [ ] Detects tool mutations (changed description/schema)
- [ ] Quarantines compromised tools
- [ ] Emits security alerts for Tool Poisoning
- [ ] Tests cover poisoning detection

**Implementation:**
```typescript
// packages/mcp-gateway/src/monitoring/tool-integrity.ts
import { MCPTool } from '../core/types.js';
import { ToolRegistry } from './tool-registry.js';
import { calculateFingerprint } from './fingerprinting.js';

export class ToolIntegrityMonitor {
  private quarantined = new Set<string>();
  
  constructor(private registry: ToolRegistry) {}
  
  async verifyIntegrity(tool: MCPTool): Promise<void> {
    // Check quarantine
    if (this.quarantined.has(tool.name)) {
      throw new ToolQuarantinedError(`Tool ${tool.name} is quarantined`);
    }
    
    // Check registration
    const registered = await this.registry.getFingerprint(tool.name);
    if (!registered) {
      throw new UnregisteredToolError(`Tool ${tool.name} not registered`);
    }
    
    // Verify integrity
    const current = calculateFingerprint(tool);
    if (current.hash !== registered.hash) {
      // CRITICAL: Tool Poisoning detected
      await this.handleToolPoisoning(tool.name, registered.hash, current.hash);
      throw new ToolPoisoningError(
        `Tool ${tool.name} integrity violation detected`
      );
    }
  }
  
  private async handleToolPoisoning(
    toolName: string,
    expectedHash: string,
    actualHash: string
  ): Promise<void> {
    // Quarantine immediately
    this.quarantined.add(toolName);
    
    // Alert security team
    await this.emitSecurityAlert({
      type: 'TOOL_POISONING_DETECTED',
      severity: 'CRITICAL',
      tool: toolName,
      expectedHash,
      actualHash,
      timestamp: new Date(),
    });
  }
  
  private async emitSecurityAlert(alert: any): Promise<void> {
    // Placeholder - logging in Epic 3.7
    console.error('[SECURITY ALERT]', JSON.stringify(alert, null, 2));
  }
}
```

**Verification:**
```bash
pnpm --filter @forge/mcp-gateway test:tool-poisoning
```

---

## Epic 3.5 Verification

**Run all tests:**
```bash
#!/bin/bash
cd packages/mcp-gateway

echo "üîç Running Epic 3.5 verification suite..."

# Unit tests
pnpm test:unit

# Integration tests
pnpm test:integration

# Coverage check
pnpm test:coverage

echo "‚úÖ Epic 3.5 complete - Ready for Epic 3.6"
```
